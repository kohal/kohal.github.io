---
    layout: post
    title: dubbo一些源码瞅瞅
---

## dubbo的线程模型

- ![dubbo的线程派发器](../images/dispatcher-location.jpg)

- 如上图，红框中的 Dispatcher 就是线程派发器。需要说明的是，Dispatcher 真实的职责创建具有线程派发能力的 ChannelHandler，比如 AllChannelHandler、MessageOnlyChannelHandler 和 ExecutionChannelHandler 等，其本身并不具备线程派发能力。Dubbo 支持 5 种不同的线程派发策略。

- 默认配置下，Dubbo 使用 all 派发策略，即将所有的消息都派发到线程池中。


- DubboProtocol的open NettyServer(default),有map的缓存，key是host:port; 值得一提的是，这边用了DCL范式保证线程安全.    
```java
private void openServer(URL url) {
        // find server.
        String key = url.getAddress();
        //client can export a service which's only for server to invoke
        boolean isServer = url.getParameter(Constants.IS_SERVER_KEY, true);
        if (isServer) {
            ExchangeServer server = serverMap.get(key);
            if (server == null) {
                synchronized (this) {v
                    server = serverMap.get(key);
                    if (server == null) {
                        serverMap.put(key, createServer(url));
                    }
                }
            } else {v
                // server supports reset, use together with override
                server.reset(url);
            }
        }
    }   
```

- nettyServer的构造方法内，NettyServer->AllDispatcher.dispatcher() ->AllChannelHandler ->(super) WrappedChannelHandler.getExecutorService()  -> FixedThreadPool(200,200,SynchronousQueue). 下面是线程池创建的开始部分.    
```java
public NettyServer(URL url, ChannelHandler handler) throws RemotingException {
        super(url, ChannelHandlers.wrap(handler, ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME)));
    }
```




